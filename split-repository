#!/usr/bin/python

from optparse import OptionParser
import git
import os, sys
import shutil
import re


# necessary imports for the overrided execute method to work as expected
import subprocess
from git.errors import GitCommandError
GIT_PYTHON_TRACE = git.cmd.GIT_PYTHON_TRACE
extra = git.cmd.extra
ON_POSIX = 'posix' in sys.builtin_module_names
extra.update({'close_fds': ON_POSIX,
              'bufsize': 1,
             })
git.cmd.execute_kwargs = ('callback',) + git.cmd.execute_kwargs

# override the default execute method of the git class with a custom one that permits
# a callback to process the command output and provide feedback to the caller
def execute(self, command,
                istream=None,
                with_keep_cwd=False,
                with_extended_output=False,
                with_exceptions=True,
                with_raw_output=False,
                callback=None,
                ):
        """
        Handles executing the command on the shell and consumes and returns
        the returned information (stdout)

        ``command``
            The command argument list to execute

        ``istream``
            Standard input filehandle passed to subprocess.Popen.

        ``with_keep_cwd``
            Whether to use the current working directory from os.getcwd().
            GitPython uses get_work_tree() as its working directory by
            default and get_git_dir() for bare repositories.

        ``with_extended_output``
            Whether to return a (status, stdout, stderr) tuple.

        ``with_exceptions``
            Whether to raise an exception when git returns a non-zero status.

        ``with_raw_output``
            Whether to avoid stripping off trailing whitespace.

        ``callback``
            User supplied callback to handle data processing

        Returns
            str(output)                     # extended_output = False (Default)
            tuple(int(status), str(output)) # extended_output = True
            callback                            # callback != None
        """

        if GIT_PYTHON_TRACE and not GIT_PYTHON_TRACE == 'full':
            print ' '.join(command)

        # Allow the user to have the command executed in their working dir.
        if with_keep_cwd or self.git_dir is None:
          cwd = os.getcwd()
        else:
          cwd=self.git_dir

        # Start the process
        proc = subprocess.Popen(command,
                                cwd=cwd,
                                stdin=istream,
                                stderr=subprocess.PIPE,
                                stdout=subprocess.PIPE,
                                **extra
                                )

        # if the user supplied a callback, use that instead.
        if callback:
            return(callback(proc))

        # Wait for the process to return
        try:
            stdout_value = proc.stdout.read()
            stderr_value = proc.stderr.read()
            status = proc.wait()
        finally:
            proc.stdout.close()
            proc.stderr.close()

        # Strip off trailing whitespace by default
        if not with_raw_output:
            stdout_value = stdout_value.rstrip()
            stderr_value = stderr_value.rstrip()

        if with_exceptions and status != 0:
            raise GitCommandError(command, status, stderr_value)

        if GIT_PYTHON_TRACE == 'full':
            if stderr_value:
              print "%s -> %d: '%s' !! '%s'" % (command, status, stdout_value, stderr_value)
            elif stdout_value:
              print "%s -> %d: '%s'" % (command, status, stdout_value)
            else:
              print "%s -> %d" % (command, status)

        # Allow access to the command's status code
        if with_extended_output:
            return (status, stdout_value, stderr_value)
        else:
            return stdout_value

# monkey patch the git.execute_process method
git.cmd.Git.execute = execute


from threading  import Thread
try:
    from Queue import Queue, Empty
except ImportError:
    from queue import Queue, Empty

def git_output_process(proc):
    def enqueue_output(out, queue):
        for line in iter(out.readline, b''):
            queue.put(line)
        out.close()

    qstdout = Queue()
    tstdout = Thread(target=enqueue_output, args=(proc.stdout, qstdout))
    tstdout.daemon = True # thread dies with the program
    tstdout.start()

    qstderr = Queue()
    tstderr = Thread(target=enqueue_output, args=(proc.stderr, qstderr))
    tstderr.daemon = True # thread dies with the program
    tstderr.start()

    commit_regex = re.compile("^Rewrite [a-z0-9]{40} \((([^\/]*)\/([^\)]*))\)")
    files_removed_regex = re.compile(".*rm '([^']*)'$")
    print "Processing commit:",

    string_len = 0
    files_removed = []
    while proc.poll() == None:
        # stdout
        try:
            line = qstdout.get_nowait()
        except Empty:
            pass
        else: # got line

            matches = commit_regex.match(line.strip())
            if matches:
                print "\b"*string_len,
                print matches.group(1),
                string_len=len(matches.group(1))+2

            matches = files_removed_regex.match(line.strip())
            if matches:
                if matches.group(1) not in files_removed:
                    files_removed.append(matches.group(1))

        # stderr
        try:
            line = qstderr.get_nowait()
        except Empty:
            pass
        else: # got line
            logging.info(line.strip())
            continue

    # finished
    print

    # summary of output processed
    print "List of files removed from history:"
    files_removed.sort()
    for file in files_removed:
        print "\t%s" % file


if __name__ == '__main__':
    parser = OptionParser(version='%prog 1.0', usage='''
Usage: %%prog [options] [args]

'''.strip('\n'))

    import logging
    logfile = "split_repo.log"
    if os.path.exists(logfile):
        os.remove(logfile)

    logging.basicConfig(format="%(message)s", filename=logfile, level=logging.INFO)

    local_clone = os.path.expanduser("~/git/localrepo")
    new_repo = os.path.expanduser("~/git/newrepo")
    paths_to_include = []

    src_repo = git.Repo(local_clone)
    assert src_repo.bare == False

    if os.path.isdir(new_repo):
        print "Existing copy found, removing to start from fresh"
        shutil.rmtree(new_repo)

    print "Cloning local repo to new path"
    shutil.copytree(local_clone + "/.git", new_repo + "/.git", symlinks=True)

    cloned_repo = git.Repo(new_repo)
    cloned_repo.git.reset(hard=True)

    # make sure the git commands are run on the correct repo
    os.chdir(new_repo)
    branches = ["master", "develop"]
    print "Pruning branches \"%s\" of everything except the following paths:" % ", ".join(branches)
    print "\n".join(paths_to_include)
    print

    protect_commits=[]
    if len(cloned_repo.git.rev_list(max_parents=0, *branches).split()) > 1:
        print "More than one root commit detected, likely some special merges combining history"
        print "are present in this repository. Searching for these merge commits to protect"

        commits=cloned_repo.git.rev_list(parents=True, merges=True, *branches)
        for commit_parents in commits.split('\n'):
            commit=commit_parents.split(' ')[0]
            parents=commit_parents.split(' ')[1:]
            mytree=cloned_repo.git.rev_parse("%s^{tree}" % commit)
            for parent in parents:
                if cloned_repo.git.rev_parse("%s^{tree}" % parents[0]) == mytree:
                    (status, output, error) = cloned_repo.git.merge_base(with_exceptions=False,
                                                                            with_extended_output=True,
                                                                            *parents)
                    if status != 0:
                        print "commit %s merges unique history, marking that it be preserved" % commit
                        protect_commits.append(commit)
                        break

    print "Protecting commits: %s" % ' '.join(protect_commits)

    protect_special_commits = ['''
if [ x${GIT_COMMIT} = x%s ]
then
    echo "Protecting special commit ${GIT_COMMIT}" >&2
    git commit-tree "$@"
    exit 0
fi
''' % special_commit for special_commit in protect_commits]

    cloned_repo.git.filter_branch("--index-filter",
                                  '''git ls-files -z | grep -z -v %s | xargs -0 --no-run-if-empty git rm --cached''' % ' '.join(['''-e \"^%s\"''' % p for p in paths_to_include]),
                                  "--commit-filter",
                                  '''
%s
if [ initial = "${3-initial}" ]
then
    # empty tree in git always hashes to "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
    if [ "$1" = "4b825dc642cb6eb9a060e54bf8d69288fbee4904" ]
    then
        skip_commit "$@"
    else
        echo "initial commit" >&2
        git_commit_non_empty_tree "$@"
    fi
else
    if [ znot_a_merge = z"${5-not_a_merge}" ]
    then
        if [ "$1" = "$(git rev-parse "$3"^{tree})" ]
        then
            skip_commit "$@"
        else
            git_commit_non_empty_tree "$@"
        fi
    else
        echo "seeing a merge: $@" >&2
        my_tree="$1"
        shift

        tmpd="/tmp/cj-git-filter-branch.$$"
        (
            umask 0077
            mkdir "$tmpd"
        )
        declare -a allparents=()
        for p in "$@"
        do
            # eliminate "-p"s
            if [ ! x"$p" = x"-p" ]
            then
                # eliminate parent doubles
                if [ ! -e "$tmpd/$p" ]
                then
                    touch "$tmpd/$p"
                    allparents+=("$p")
                fi
            fi
        done
        rm -rf "$tmpd"

        declare -a sametreeparents=()
        declare -a notsametreeparents=()
        for p in "${allparents[@]}"
        do
            if [ "$my_tree" = "$(git rev-parse "$p"^{tree})" ]
            then
                sametreeparents+=("$p")
            else
                notsametreeparents+=("$p")
            fi
        done

        if [ "${#sametreeparents[@]}" = 1 ]
        then
            keep_merge=0
            sametreeparent="${sametreeparents[0]}"
            declare -a neededparents=()
            for p in "${notsametreeparents[@]}"
            do
                set +e
                mb=$(git merge-base "$sametreeparent" "$p")
                rc=$?
                set -e
                if [ $rc = 0 ]
                then
                    if [ ! "$mb" = "$p" ]
                    then
                        neededparents+=("$p")
                    fi
                elif [ $rc = 1 ]
                then
                    echo "non-common ancestors, keeping merge" >&2
                    keep_merge=1
                else
                    die "git merge-base had a problem"
                fi
            done

            if [ "${#neededparents[@]}" = 0 -a "${keep_merge}" = 0 ]
            then
                skip_commit "$my_tree" -p "$sametreeparent"
            else
                # still drop the parents that have no effect, ok?
                declare -a newargs=(-p "$sametreeparent")
                for p in "${neededparents[@]}"
                do
                    newargs+=(-p)
                    newargs+=("$p")
                done
                git_commit_non_empty_tree "$my_tree" "${newargs[@]}"
            fi
        else
            # (could have doubles in $@ ? anyway, let git get rid of them)
            git_commit_non_empty_tree "$my_tree" "$@"
        fi
    fi
fi
''' % ' '.join(protect_special_commits),
                                "-f",
                                *branches,
                                callback=git_output_process)
