#!/usr/bin/python

from optparse import OptionParser
import git
import git_callback
from filterbranch import FilterBranch
import os, sys
import shutil
import re
import logging, logging.handlers

from threading  import Thread
try:
    from Queue import Queue, Empty
except ImportError:
    from queue import Queue, Empty

def git_output_process(proc):
    def enqueue_output(out, queue):
        for line in iter(out.readline, b''):
            queue.put(line)
        out.close()

    qstdout = Queue()
    tstdout = Thread(target=enqueue_output, args=(proc.stdout, qstdout))
    tstdout.daemon = True # thread dies with the program
    tstdout.start()

    qstderr = Queue()
    tstderr = Thread(target=enqueue_output, args=(proc.stderr, qstderr))
    tstderr.daemon = True # thread dies with the program
    tstderr.start()

    commit_regex = re.compile("^Rewrite [a-z0-9]{40} \((([^\/]*)\/([^\)]*))\)")
    files_removed_regex = re.compile(".*rm '([^']*)'$")
    print "Processing commit:",

    logger = logging.getLogger()

    string_len = 0
    files_removed = []
    while proc.poll() == None:
        # stdout
        try:
            line = qstdout.get_nowait()
        except Empty:
            pass
        else: # got line

            matches = commit_regex.match(line.strip())
            if matches:
                print "\b"*string_len,
                print matches.group(1),
                string_len=len(matches.group(1))+2

            matches = files_removed_regex.match(line.strip())
            if matches:
                if matches.group(1) not in files_removed:
                    files_removed.append(matches.group(1))

        # stderr
        try:
            line = qstderr.get_nowait()
        except Empty:
            pass
        else: # got line
            logger.info(line.strip())
            continue

    # finished
    print

    # summary of output processed
    print "List of files removed from history:"
    files_removed.sort()
    for file in files_removed:
        print "\t%s" % file


if __name__ == '__main__':
    parser = OptionParser(version='%prog 1.0', usage='''Usage: %prog [options]''',
                          description='''
Splits an existing repository based on a list of files/patterns
to be kept, with all history preserved and any empty commits,
including merge commits, pruned and placed under a new repository.
'''.strip('\n'))
    parser.add_option('-i', '--include-file', dest='include_file',
                      help='File containing patterns to include, one per line. ' \
                           'Basename of file will be used as the target repository ' \
                           'name and for the log file unless -n, --new-repo is set.')
    parser.add_option('-I', '--include', dest='file_pattern',
                      help='Whitespace separated list of files to include. ' \
                           'Appended to the pattern list specified by --include-file. ' \
                           'Cannot be used when multiple --include-file set.')
    parser.add_option('-r', '--src-repo', dest='src_repo',
                      help='Source repository to split. If this is local the script ' \
                           'will use it as a reference and still attempt to retrieve ' \
                           'from the original remote repo. To prevent querying of the '
                           'remote, remove the "origin" remote from the git repo.')
    parser.add_option('-n', '--new-repo', dest='target_repo',
                      help='Sets the target repository name. Created at the given path ' \
                           '(if value is a path), at the same level if just a name and ' \
                           'source repo is local or in the current working directory')
    parser.add_option('-f', '--force', action='store_true', default=False,
                      help='Force overwriting of the target path if it exists')
    parser.add_option('-b', '--branch', dest='branches', action='append',
                      help='Name of branch to process. May be specified multiple times. ' \
                           'Default is to process all branches.')
    parser.add_option('-p', '--prune', action='store_true', default=False,
                      help='Prune new repository of any branches that reference a commit ' \
                           'that is reachable from any branch specified by "--keep-branch"')
    parser.add_option('-k', '--keep-branch', action="append", dest="keep_branches",
                      help='Name of branches to prevent from being pruned. Specify one for '
                           'each branch to be kept.')

    (options, args) = parser.parse_args(sys.argv[1:])

    # resolve any options
    include_patterns = []
    include_file = options.include_file
    new_repo_name = None
    logfile = "split.log"
    if include_file != None:
        if not os.path.exists(include_file):
            print "Specified include file does not exist: %s" % include_file
            sys.exit(1)
        include_patterns = [line.strip() \
                            for line in open(include_file, 'r').read().split('\n') \
                                if line and line[0] != "#" ]
        new_repo_name = os.path.splitext(os.path.basename(include_file))[0]

    if options.file_pattern:
        include_patterns.extend([pattern.strip() \
                                 for pattern in options.file_pattern.split() \
                                    if pattern
                                ])

    if include_patterns == []:
        parser.error("No include pattern specified! Cannot prune repo! Set -i or -I.")

    # determine source repository to use, and whether we need to clone a local copy to
    # allow for rapid re-runs or just copy the existing local repo to the target repo and
    # prune
    clone_options = []
    if not options.src_repo:
        parser.error("No source repository specified to use! Set -s, --src-repo")
    else:
        if options.src_repo[:7] == "file://":
            src_repo = options.src_repo[7:]
        else:
            src_repo = options.src_repo

        if os.path.exists(src_repo):
            print "Using local path clone"
            clone_options.append("--no-hardlinks")
        else:
            print "Need to create a local clone of the remote repository"
            print "Currently not supported by this script"
            sys.exit(1)

    if options.target_repo:
        new_repo_name = options.target_repo

    if not new_repo_name:
        parser.error("No target repository set. Set -i or -n")

    # determine full target path for the target repository
    if os.path.sep in new_repo_name:
        # path
        new_repo = new_repo_name
    else:
        new_repo = os.path.join(os.path.dirname(src_repo.rstrip(os.path.sep)), new_repo_name)

    # branch pruning options
    keep_branches = []
    if options.prune:
        if options.keep_branches:
            keep_branches = options.keep_branches
        else:
            keep_branches = ["master"]

    # sort out logging
    logfile = "%s.log" % os.path.basename(new_repo.rstrip(os.path.sep))
    print "Using logfile: %s" % logfile
    logger = logging.getLogger()
    rh = logging.handlers.RotatingFileHandler(logfile, backupCount=10)
    rh.setFormatter(logging.Formatter("%(message)s"))
    logger.setLevel(logging.DEBUG)
    logger.addHandler(rh)

    if os.path.isfile(logfile) and os.path.getsize(logfile) > 0:
        rh.doRollover()

    local_clone = git.Repo(src_repo)
    assert local_clone.bare == False

    if os.path.exists(new_repo):
        if options.force:
            print "Existing copy found, removing to start from fresh"
            shutil.rmtree(new_repo)
        else:
            parser.error("Target repository path (%s) already exists, cannot create" % new_repo)

    print "Cloning local repo to new path"
    remote_ref = local_clone.git.config("--get", "remote.origin.url", with_exceptions=False)
    if remote_ref:
        local_clone.git.clone("--reference", src_repo, remote_ref,
                              os.path.abspath(new_repo))
    else:
        local_clone.git.clone(src_repo, os.path.abspath(new_repo))

    # make sure the git commands are run on the correct repo
    os.chdir(os.path.abspath(new_repo))
    new_clone = git.Repo(new_repo)

    # make local branches of all remote branches, and prune them all
    remote_branches = new_clone.git.for_each_ref("--format","%(refname:short)","refs/remotes/origin/")
    ignore_remote_branches = ["HEAD"]
    ignore_remote_branches.append(new_clone.git.rev_parse("--abbrev-ref","HEAD").strip())
    for origin_branch in remote_branches.split():
        if origin_branch == None:
            continue
        branch = origin_branch[7:]
        if branch not in ignore_remote_branches:
            new_clone.git.branch(branch, origin_branch)
    new_clone.git.remote("rm", "origin")

    branches = ["--", "--all"]
    if options.branches:
        branches = options.branches

    print "Pruning branches \"%s\" of everything except the following paths:" % ", ".join(branches)
    print "\n".join(include_patterns)
    print

    debug_lvl=3
    new_clone.git.filter_branch("--index-filter",
                                  FilterBranch.index_filter % ' '.join(['''-e \"^%s\"''' % p for p in include_patterns]),
                                  "--commit-filter",
                                  FilterBranch.commit_filter % debug_lvl,
                                  "-f",
                                  *branches,
                                  callback=git_output_process)

    # clean up
    print "Removing refs/original/*"
    for ref in new_clone.git.for_each_ref("--format=%(refname)", "refs/original/").split():
        logger.info("Deleteing %s" % ref)
        new_clone.git.update_ref("-d", ref)

    new_clone.git.reflog("expire", "--expire=now", "--all")
    new_clone.git.gc(aggressive=True, prune="now")

    # prune branches that point to the same ref
    if keep_branches != []:
        print "Pruning duplicate branches"
    for branch in keep_branches:
        new_clone.git.checkout(branch)
        prune_list = new_clone.git.branch("--no-color", "--merged", branch).split('\n')
        for prune_branch in prune_list:
            prune_branch = prune_branch.strip(' *')
            if prune_branch not in keep_branches:
                logger.info("Pruning %s" % prune_branch)
                new_clone.git.branch("-d", prune_branch)

    # switch back to default branch
    new_clone.git.checkout("master")
