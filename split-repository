#!/usr/bin/python

from optparse import OptionParser
import git
import git_callback
import os, sys
import shutil
import re

from threading  import Thread
try:
    from Queue import Queue, Empty
except ImportError:
    from queue import Queue, Empty

def git_output_process(proc):
    def enqueue_output(out, queue):
        for line in iter(out.readline, b''):
            queue.put(line)
        out.close()

    qstdout = Queue()
    tstdout = Thread(target=enqueue_output, args=(proc.stdout, qstdout))
    tstdout.daemon = True # thread dies with the program
    tstdout.start()

    qstderr = Queue()
    tstderr = Thread(target=enqueue_output, args=(proc.stderr, qstderr))
    tstderr.daemon = True # thread dies with the program
    tstderr.start()

    commit_regex = re.compile("^Rewrite [a-z0-9]{40} \((([^\/]*)\/([^\)]*))\)")
    files_removed_regex = re.compile(".*rm '([^']*)'$")
    print "Processing commit:",

    string_len = 0
    files_removed = []
    while proc.poll() == None:
        # stdout
        try:
            line = qstdout.get_nowait()
        except Empty:
            pass
        else: # got line

            matches = commit_regex.match(line.strip())
            if matches:
                print "\b"*string_len,
                print matches.group(1),
                string_len=len(matches.group(1))+2

            matches = files_removed_regex.match(line.strip())
            if matches:
                if matches.group(1) not in files_removed:
                    files_removed.append(matches.group(1))

        # stderr
        try:
            line = qstderr.get_nowait()
        except Empty:
            pass
        else: # got line
            logging.info(line.strip())
            continue

    # finished
    print

    # summary of output processed
    print "List of files removed from history:"
    files_removed.sort()
    for file in files_removed:
        print "\t%s" % file


if __name__ == '__main__':
    parser = OptionParser(version='%prog 1.0', usage='''
Usage: %%prog [options] [args]

'''.strip('\n'))

    import logging
    logfile = "split_repo.log"
    if os.path.exists(logfile):
        os.remove(logfile)

    logging.basicConfig(format="%(message)s", filename=logfile, level=logging.INFO)

    local_clone = os.path.expanduser("~/git/localrepo")
    new_repo = os.path.expanduser("~/git/newrepo")
    paths_to_include = []

    src_repo = git.Repo(local_clone)
    assert src_repo.bare == False

    if os.path.isdir(new_repo):
        print "Existing copy found, removing to start from fresh"
        shutil.rmtree(new_repo)

    print "Cloning local repo to new path"
    shutil.copytree(local_clone + "/.git", new_repo + "/.git", symlinks=True)

    cloned_repo = git.Repo(new_repo)
    cloned_repo.git.reset(hard=True)

    # make sure the git commands are run on the correct repo
    os.chdir(new_repo)
    branches = ["master", "develop"]
    print "Pruning branches \"%s\" of everything except the following paths:" % ", ".join(branches)
    print "\n".join(paths_to_include)
    print

    debug_lvl=3
    cloned_repo.git.filter_branch("--index-filter",
                                  '''git ls-files -z | grep -z -v %s | xargs -0 --no-run-if-empty git rm --cached''' % ' '.join(['''-e \"^%s\"''' % p for p in paths_to_include]),
                                  "--commit-filter",
                                  '''
DEBUG_LVL=%d
DEBUG_LVL=${DEBUG_LVL:-0}

function log_warn() {
    [ "${DEBUG_LVL}" -ge 3 -a "$*" != "" ] && echo "$*" >&2
}

function log_info() {
    [ "${DEBUG_LVL}" -ge 2 -a "$*" != "" ] && echo "$*" >&2
}

function log_debug() {
    [ "${DEBUG_LVL}" -ge 1 -a "$*" != "" ] && echo "$*" >&2
}

log_debug "args = $@"
log_debug "$(git ls-files)"

if [ initial = "${3-initial}" ]
then
    # empty tree in git always hashes to "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
    if [ "$1" = "4b825dc642cb6eb9a060e54bf8d69288fbee4904" ]
    then
        log_info "skipped empty tree"
        skip_commit "$@"
    else
        log_warn "initial commit"
        git_commit_non_empty_tree "$@"
    fi
else
    if [ znot_a_merge = z"${5-not_a_merge}" ]
    then
        if [ "$1" = "$(git rev-parse "$3"^{tree})" ]
        then
            log_info "skipped"
            skip_commit "$@"
        else
            log_info "committed (if non empty) - not a merge"
            git_commit_non_empty_tree "$@"
        fi
    else
        log_warn "seeing a merge: $@"
        my_tree="$1"
        shift

        tmpd="/tmp/cj-git-filter-branch.$$"
        (
            umask 0077
            mkdir "$tmpd"
        )
        declare -a allparents=()
        for p in "$@"
        do
            # eliminate "-p"s
            if [ ! x"$p" = x"-p" ]
            then
                # eliminate parent doubles
                if [ ! -e "$tmpd/$p" ]
                then
                    touch "$tmpd/$p"
                    allparents+=("$p")
                fi
            fi
        done
        rm -rf "$tmpd"

        declare -a sametreeparents=()
        declare -a notsametreeparents=()
        for p in "${allparents[@]}"
        do
            if [ "$my_tree" = "$(git rev-parse "$p"^{tree})" ]
            then
                sametreeparents+=("$p")
            else
                notsametreeparents+=("$p")
            fi
        done

        log_debug "sametreeparents=${sametreeparents[@]}"
        log_debug "notsametreeparents=${notsametreeparents[@]}"
        if [ "${#sametreeparents[@]}" -ge 1 ]
        then
            declare -a neededparents=()
            for sametreeparent in "${sametreeparents[0]}"
            do
                for p in "${notsametreeparents[@]}"
                do
                    set +e
                    mb=$(git merge-base "$sametreeparent" "$p")
                    rc=$?
                    set -e
                    if [ $rc = 0 ]
                    then
                        if [ ! "$mb" = "$p" ]
                        then
                            neededparents+=("$p")
                        fi
                    elif [ $rc = 1 ]
                    then
                        log_warn "non-common ancestors, keeping merge"
                        neededparents+=("$p")
                    else
                        die "git merge-base had a problem"
                    fi
                done
            done

            if [ "${#neededparents[@]}" = 0 ]
            then
                log_info "skipped - no parents needed"
                log_debug "skip_commit (#neededparents[@] == 0)\"$my_tree\" -p \"$sametreeparent\""
                skip_commit "$my_tree" -p "$sametreeparent"
            else
                # still drop the parents that have no effect, ok?
                declare -a newargs=(-p "$sametreeparent")
                for p in "${neededparents[@]}"
                do
                    newargs+=(-p)
                    newargs+=("$p")
                done
                log_info "committed (if non empty) sametreeparents == 1" >&2
                log_debug "git_commit_non_empty_tree \"$my_tree\" \"${newargs[@]}\""
                git_commit_non_empty_tree "$my_tree" "${newargs[@]}"
            fi
        else
            log_info "committed (if non empty) sametreeparents >1"
            log_debug "git_commit_non_empty_tree \"$my_tree\" \"$@\""
            # (could have doubles in $@ ? anyway, let git get rid of them)
            git_commit_non_empty_tree "$my_tree" "$@"
        fi
    fi
fi
''' % debug_lvl,
                                "-f",
                                *branches,
                                callback=git_output_process)
