#!/usr/bin/python

from optparse import OptionParser
import git
import os, sys, fcntl
import shutil
import re

# override the default execute method of the git class with a custom one that permits
# a callback to process the command output and provide feedback to the caller
def execute(self, command,
                istream=None,
                with_keep_cwd=False,
                with_extended_output=False,
                with_exceptions=True,
                with_raw_output=False,
                callback=None,
                ):
        """
        Handles executing the command on the shell and consumes and returns
        the returned information (stdout)

        ``command``
            The command argument list to execute

        ``istream``
            Standard input filehandle passed to subprocess.Popen.

        ``with_keep_cwd``
            Whether to use the current working directory from os.getcwd().
            GitPython uses get_work_tree() as its working directory by
            default and get_git_dir() for bare repositories.

        ``with_extended_output``
            Whether to return a (status, stdout, stderr) tuple.

        ``with_exceptions``
            Whether to raise an exception when git returns a non-zero status.

        ``with_raw_output``
            Whether to avoid stripping off trailing whitespace.

        Returns
            str(output)                     # extended_output = False (Default)
            tuple(int(status), str(output)) # extended_output = True
        """

        if GIT_PYTHON_TRACE and not GIT_PYTHON_TRACE == 'full':
            print ' '.join(command)

        # Allow the user to have the command executed in their working dir.
        if with_keep_cwd or self.git_dir is None:
          cwd = os.getcwd()
        else:
          cwd=self.git_dir

        # Start the process
        proc = subprocess.Popen(command,
                                cwd=cwd,
                                stdin=istream,
                                stderr=subprocess.PIPE,
                                stdout=subprocess.PIPE,
                                **extra
                                )

        # Wait for the process to return
        try:
            if callback:
                callback(proc)
            stdout_value = proc.stdout.read()
            stderr_value = proc.stderr.read()
            status = proc.wait()
        finally:
            proc.stdout.close()
            proc.stderr.close()

        # Strip off trailing whitespace by default
        if not with_raw_output:
            stdout_value = stdout_value.rstrip()
            stderr_value = stderr_value.rstrip()

        if with_exceptions and status != 0:
            raise GitCommandError(command, status, stderr_value)

        if GIT_PYTHON_TRACE == 'full':
            if stderr_value:
              print "%s -> %d: '%s' !! '%s'" % (command, status, stdout_value, stderr_value)
            elif stdout_value:
              print "%s -> %d: '%s'" % (command, status, stdout_value)
            else:
              print "%s -> %d" % (command, status)

        # Allow access to the command's status code
        if with_extended_output:
            return (status, stdout_value, stderr_value)
        else:
            return stdout_value

# monkey patch the python git class method git.cmd.Git.execute
import subprocess
from git.errors import GitCommandError
GIT_PYTHON_TRACE = git.cmd.GIT_PYTHON_TRACE
extra = git.cmd.extra
ON_POSIX = 'posix' in sys.builtin_module_names
extra.update({'close_fds': ON_POSIX})
git.cmd.execute_kwargs = ('callback',) + git.cmd.execute_kwargs
git.cmd.Git.execute = execute


def git_progress(proc):

    # force unbuffered input
    for ostream in [proc.stdout, proc.stderr]:
        fd = ostream.fileno()
        fl = fcntl.fcntl(fd, fcntl.F_GETFL)
        fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

    regex = re.compile("^Rewrite [a-z0-9]{40} \((([^\/]*)\/([^\)]*))\)")
    print "Processing commit:",
    string_len = 0
    indexend = False
    while proc.poll() == None:
        try:
            next_err_line = proc.stderr.readline()
            if next_err_line:
                next_err_line = next_err_line.strip()
                print next_err_line
        except IOError:
            pass

        try:
            next_line = proc.stdout.readline()
            if not next_line:
                continue
        except IOError:
            continue
#        matches = regex.match(next_line)
#        if matches and not indexend:
#            print "\b"*string_len,
#            print matches.group(1),
#            string_len=len(matches.group(1))+2
#            if matches.group(2) == matches.group(3):
#                indexend=True
#
#        if indexend:
#            print next_line
        next_line = next_line.strip()
        print next_line

#    while True:
#        next_err_line = stderr.readline()
#        if not next_line:
#            break
#        print next_line

    return


if __name__ == '__main__':
    parser = OptionParser(version='%prog 1.0', usage='''
Usage: %%prog [options] [args]

'''.strip('\n'))

    local_clone = os.path.expanduser("~/git/localrepo")
    new_repo = os.path.expanduser("~/git/newrepo")
    paths_to_include = []

    src_repo = git.Repo(local_clone)
    assert src_repo.bare == False

    if os.path.isdir(new_repo):
        print "Existing copy found, removing to start from fresh"
        shutil.rmtree(new_repo)

    print "Cloning local repo to new path"
    shutil.copytree(local_clone + "/.git", new_repo + "/.git", symlinks=True)

    cloned_repo = git.Repo(new_repo)
    cloned_repo.git.reset(hard=True)

    # make sure the git commands are run on the correct repo
    os.chdir(new_repo)
    branches = ["master", "develop"]
    print "Pruning branches \"%s\" of everything except the following paths:" % ", ".join(branches)
    print "\n".join(paths_to_include)
    print

    # remove files not needed in the new repo
    cloned_repo.git.filter_branch("--index-filter",
                                  '''git ls-files -z | grep -z -v %s | xargs -0 --no-run-if-empty git rm --cached''' % ' '.join(['''-e \"%s\"''' % p for p in paths_to_include]),
                                  "--commit-filter",'''
if [ initial = "${3-initial}" ]
then
    echo "initial commit" >&2
    git commit-tree "$@"
else
    if [ znot_a_merge = z"${5-not_a_merge}" ]
    then
        if [ "$1" = "$(git rev-parse "$3"^{tree})" ]
        then
            skip_commit "$@"
        else
            git commit-tree "$@"
        fi
    else
        echo "seeing a merge: $@" >&2
        my_tree="$1"
        shift

        tmpd="/tmp/cj-git-filter-branch.$$"
        (
            umask 0077
            mkdir "$tmpd"
        )
        declare -a allparents=()
        for p in "$@"
        do
            # eliminate "-p"s
            if [ ! x"$p" = x"-p" ]
            then
                # eliminate parent doubles
                if [ ! -e "$tmpd/$p" ]
                then
                    touch "$tmpd/$p"
                    allparents+=("$p")
                fi
            fi
        done
        rm -rf "$tmpd"

        declare -a sametreeparents=()
        declare -a notsametreeparents=()
        for p in "${allparents[@]}"
        do
            if [ "$my_tree" = "$(git rev-parse "$p"^{tree})" ]
            then
                sametreeparents+=("$p")
            else
                notsametreeparents+=("$p")
            fi
        done

        if [ "${#sametreeparents[@]}" = 1 ]
        then
            sametreeparent="${sametreeparents[0]}"
            declare -a neededparents=()
            for p in "${notsametreeparents[@]}"
            do
                set +e
                mb=$(git merge-base "$sametreeparent" "$p")
                rc=$?
                set -e
                if [ $rc = 0 ]
                then
                    if [ ! "$mb" = "$p" ]
                    then
                        neededparents+=("$p")
                    fi
                elif [ $rc = 1 ]
                then
                    echo "non-common ancestors, keeping merge" >&2
                else
                    die "git merge-base had a problem"
                fi
            done

            if [ "${#neededparents[@]}" = 0 ]
            then
                skip_commit "$my_tree" -p "$sametreeparent"
            else
                # still drop the parents that have no effect, ok?
                declare -a newargs=(-p "$sametreeparent")
                for p in "${neededparents[@]}"
                do
                    newargs+=(-p)
                    newargs+=("$p")
                done
                git commit-tree "$my_tree" "${newargs[@]}"
            fi
        else
            # (could have doubles in $@ ? anyway, let git get rid of them)
            git commit-tree "$my_tree" "$@"
        fi
    fi
fi
''',
                                "-f",
                                *branches,
                                callback=git_progress)
