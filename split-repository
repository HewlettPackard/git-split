#!/usr/bin/python

from optparse import OptionParser
import git
import git_callback
from filterbranch import FilterBranch
import os, sys
import shutil
import re
import logging, logging.handlers

from threading  import Thread
try:
    from Queue import Queue, Empty
except ImportError:
    from queue import Queue, Empty

def git_output_process(proc):
    def enqueue_output(out, queue):
        for line in iter(out.readline, b''):
            queue.put(line)
        out.close()

    qstdout = Queue()
    tstdout = Thread(target=enqueue_output, args=(proc.stdout, qstdout))
    tstdout.daemon = True # thread dies with the program
    tstdout.start()

    qstderr = Queue()
    tstderr = Thread(target=enqueue_output, args=(proc.stderr, qstderr))
    tstderr.daemon = True # thread dies with the program
    tstderr.start()

    commit_regex = re.compile("^Rewrite [a-z0-9]{40} \((([^\/]*)\/([^\)]*))\)")
    files_removed_regex = re.compile(".*rm '([^']*)'$")
    print "Processing commit:",

    logger = logging.getLogger()

    string_len = 0
    files_removed = []
    while proc.poll() == None:
        # stdout
        try:
            line = qstdout.get_nowait()
        except Empty:
            pass
        else: # got line

            matches = commit_regex.match(line.strip())
            if matches:
                print "\b"*string_len,
                print matches.group(1),
                string_len=len(matches.group(1))+2

            matches = files_removed_regex.match(line.strip())
            if matches:
                if matches.group(1) not in files_removed:
                    files_removed.append(matches.group(1))

        # stderr
        try:
            line = qstderr.get_nowait()
        except Empty:
            pass
        else: # got line
            logger.info(line.strip())
            continue

    # finished
    print

    # summary of output processed
    print "List of files removed from history:"
    files_removed.sort()
    for file in files_removed:
        print "\t%s" % file


if __name__ == '__main__':
    parser = OptionParser(version='%prog 1.0', usage='''
Usage: %prog [options] [args]

Splits an existing repository based on a list of files/patterns
to be kept, with all history preserved and any empty commits,
including merge commits, pruned and placed under a new repository.

'''.strip('\n'))
    parser.add_option('-i', '--include-file', dest='include_file',
                      help='File containing patterns to include, one per line. ' \
                           'Basename of file will be used as the target repository ' \
                           'name and for the log file unless -n, --new-repo is set.')
    parser.add_option('-I', '--include', dest='file_pattern',
                      help='Whitespace separated list of files to include. ' \
                           'Appended to the pattern list specified by --include-file. ' \
                           'Cannot be used when multiple --include-file set.')

    (options, args) = parser.parse_args(sys.argv[1:])

    # resolve any options
    include_patterns = []
    include_file = options.include_file
    new_repo = ""
    logfile = "split.log"
    if include_file != None:
        if not os.path.exists(include_file):
            print "Specified include file does not exist: %s" % include_file
            sys.exit(1)
        include_patterns = [line.strip() \
                            for line in open(include_file, 'r').read().split('\n') \
                                if line and line[0] != "#" ]
        new_repo = os.path.splitext(os.path.basename(include_file))[0]
        logfile = "%s.log" % new_repo

    if options.file_pattern:
        include_patterns.extend([pattern.strip() \
                                 for pattern in options.file_pattern.split() \
                                    if pattern
                                ])

    if include_patterns == []:
        print "No include pattern specified! Cannot prune repo!"
        sys.exit(2)


    # sort out logging
    print "Using logfile: %s" % logfile
    logger = logging.getLogger()
    rh = logging.handlers.RotatingFileHandler(logfile, backupCount=10)
    rh.setFormatter(logging.Formatter("%(message)s"))
    logger.setLevel(logging.DEBUG)
    logger.addHandler(rh)

    if os.path.isfile(logfile) and os.path.getsize(logfile) > 0:
        rh.doRollover()

    local_clone = os.path.expanduser("~/git/localrepo")
    new_repo = os.path.expanduser("~/git/newrepo")

    src_repo = git.Repo(local_clone)
    assert src_repo.bare == False

    if os.path.isdir(new_repo):
        print "Existing copy found, removing to start from fresh"
        shutil.rmtree(new_repo)

    print "Cloning local repo to new path"
    shutil.copytree(local_clone + "/.git", new_repo + "/.git", symlinks=True)

    cloned_repo = git.Repo(new_repo)
    cloned_repo.git.reset(hard=True)

    # make sure the git commands are run on the correct repo
    os.chdir(new_repo)
    branches = ["master", "develop"]
    print "Pruning branches \"%s\" of everything except the following paths:" % ", ".join(branches)
    print "\n".join(include_patterns)
    print

    debug_lvl=3
    cloned_repo.git.filter_branch("--index-filter",
                                  FilterBranch.index_filter % ' '.join(['''-e \"^%s\"''' % p for p in include_patterns]),
                                  "--commit-filter",
                                  FilterBranch.commit_filter % debug_lvl,
                                  "-f",
                                  *branches,
                                  callback=git_output_process)
