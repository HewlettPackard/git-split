#!/usr/bin/python

from optparse import OptionParser
import git
import git_callback
from filterbranch import FilterBranch
import os, sys
import shutil
import re
import logging

from threading  import Thread
try:
    from Queue import Queue, Empty
except ImportError:
    from queue import Queue, Empty

def git_output_process(proc):
    def enqueue_output(out, queue):
        for line in iter(out.readline, b''):
            queue.put(line)
        out.close()

    qstdout = Queue()
    tstdout = Thread(target=enqueue_output, args=(proc.stdout, qstdout))
    tstdout.daemon = True # thread dies with the program
    tstdout.start()

    qstderr = Queue()
    tstderr = Thread(target=enqueue_output, args=(proc.stderr, qstderr))
    tstderr.daemon = True # thread dies with the program
    tstderr.start()

    commit_regex = re.compile("^Rewrite [a-z0-9]{40} \((([^\/]*)\/([^\)]*))\)")
    files_removed_regex = re.compile(".*rm '([^']*)'$")
    print "Processing commit:",

    string_len = 0
    files_removed = []
    while proc.poll() == None:
        # stdout
        try:
            line = qstdout.get_nowait()
        except Empty:
            pass
        else: # got line

            matches = commit_regex.match(line.strip())
            if matches:
                print "\b"*string_len,
                print matches.group(1),
                string_len=len(matches.group(1))+2

            matches = files_removed_regex.match(line.strip())
            if matches:
                if matches.group(1) not in files_removed:
                    files_removed.append(matches.group(1))

        # stderr
        try:
            line = qstderr.get_nowait()
        except Empty:
            pass
        else: # got line
            logging.info(line.strip())
            continue

    # finished
    print

    # summary of output processed
    print "List of files removed from history:"
    files_removed.sort()
    for file in files_removed:
        print "\t%s" % file


if __name__ == '__main__':
    parser = OptionParser(version='%prog 1.0', usage='''
Usage: %%prog [options] [args]

'''.strip('\n'))

    logfile = "split_repo.log"
    if os.path.exists(logfile):
        os.remove(logfile)

    logging.basicConfig(format="%(message)s", filename=logfile, level=logging.INFO)

    local_clone = os.path.expanduser("~/git/localrepo")
    new_repo = os.path.expanduser("~/git/newrepo")
    paths_to_include = []

    src_repo = git.Repo(local_clone)
    assert src_repo.bare == False

    if os.path.isdir(new_repo):
        print "Existing copy found, removing to start from fresh"
        shutil.rmtree(new_repo)

    print "Cloning local repo to new path"
    shutil.copytree(local_clone + "/.git", new_repo + "/.git", symlinks=True)

    cloned_repo = git.Repo(new_repo)
    cloned_repo.git.reset(hard=True)

    # make sure the git commands are run on the correct repo
    os.chdir(new_repo)
    branches = ["master", "develop"]
    print "Pruning branches \"%s\" of everything except the following paths:" % ", ".join(branches)
    print "\n".join(paths_to_include)
    print

    debug_lvl=3
    cloned_repo.git.filter_branch("--index-filter",
                                  FilterBranch.index_filter % ' '.join(['''-e \"^%s\"''' % p for p in paths_to_include]),
                                  "--commit-filter",
                                  FilterBranch.commit_filter % debug_lvl,
                                  "-f",
                                  *branches,
                                  callback=git_output_process)
