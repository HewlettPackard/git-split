#!/usr/bin/python

from optparse import OptionParser
import git
import git_callback
from filterbranch import FilterBranch
import os, sys
import shutil
import re
import logging, logging.handlers

from threading  import Thread
try:
    from Queue import Queue, Empty
except ImportError:
    from queue import Queue, Empty

def shortest_exclusive_paths(excludes, includes):

    logger = logging.getLogger()

    includes.sort()
    includes_dict = {}
    for file in includes:
        dict = includes_dict
        for path_item in file.split(os.path.sep):
            if not path_item in dict:
                dict[path_item] = {}
            dict = dict[path_item]

    excludes.sort()

    exclusive = []
    for file in excludes:
        dict = includes_dict
        file_paths = os.path.normpath(file).split(os.path.sep)
        for i, path_item in enumerate(file_paths, 1):
            logger.debug("searching %s for %s" % (dict, path_item))
            if not path_item in dict:
                short_path = os.path.join(*file_paths[:i])
                if short_path not in exclusive:
                    exclusive.append(short_path)
                else:
                    logger.debug("didn't find %s" % short_path)
                break

            dict = dict[path_item]

    return(exclusive)

def git_output_process(keep_files, proc):
    def enqueue_output(out, queue):
        for line in iter(out.readline, b''):
            queue.put(line)
        out.close()

    qstdout = Queue()
    tstdout = Thread(target=enqueue_output, args=(proc.stdout, qstdout))
    tstdout.daemon = True # thread dies with the program
    tstdout.start()

    qstderr = Queue()
    tstderr = Thread(target=enqueue_output, args=(proc.stderr, qstderr))
    tstderr.daemon = True # thread dies with the program
    tstderr.start()

    commit_regex = re.compile("^Rewrite [a-z0-9]{40} \((([^\/]*)\/([^\)]*))\)")
    files_removed_regex = re.compile(".*rm '([^']*)'$")
    print "Processing commit:",

    logger = logging.getLogger()

    string_len = 0
    files_removed = []
    while proc.poll() == None:
        # stdout
        try:
            stdout_line = qstdout.get_nowait()
        except Empty:
            pass
        else: # got line

            stdout_line = stdout_line.strip()
            logger.debug(stdout_line)
            matches = commit_regex.match(stdout_line)
            if matches:
                print "\b"*string_len,
                print matches.group(1),
                string_len=len(matches.group(1))+2

            matches = files_removed_regex.match(stdout_line)
            if matches:
                if matches.group(1) not in files_removed:
                    files_removed.append(matches.group(1))

        # stderr
        try:
            stderr_line = qstderr.get_nowait()
        except Empty:
            pass
        else: # got line
            stderr_line = stderr_line.strip()
            logger.info(stderr_line)

    # finished
    print

    # summary of output processed
    print "List of files removed from history:"
    for file in shortest_exclusive_paths(files_removed, keep_files):
        print "\t%s" % file

    return(proc.returncode, stdout_line, stderr_line)

def split_repo(src_repo, include_file, include_pattern, target_repo, branches, prune, 
                keep_branches, force=False):

    new_repo_name = target_repo
    includes = []
    if include_file != None:
        if not os.path.exists(include_file):
            print "Specified include file does not exist: %s" % include_file
            sys.exit(1)
        includes = [line.strip() \
                            for line in open(include_file, 'r').read().split('\n') \
                                if line and line[0] != "#" ]
        if not new_repo_name:
            new_repo_name = os.path.splitext(os.path.basename(include_file))[0]

    if include_pattern:
        includes.extend([pattern.strip() \
                                for pattern in include_pattern.split() \
                                    if pattern
                                ])

    if includes == []:
        print "No include pattern specified! Cannot prune repo!"
        return False

    # determine full target path for the target repository
    if os.path.sep in new_repo_name:
        # path
        new_repo = new_repo_name
    else:
        new_repo = os.path.join(os.path.dirname(src_repo.rstrip(os.path.sep)), new_repo_name)

    # sort out logging
    logfile = "%s.log" % os.path.basename(new_repo.rstrip(os.path.sep))
    print "Using logfile: %s" % logfile
    logger = logging.getLogger()
    rh = logging.handlers.RotatingFileHandler(logfile, backupCount=10)
    rh.setFormatter(logging.Formatter("%(message)s"))
    logger.setLevel(logging.DEBUG)
    logger.addHandler(rh)

    if os.path.isfile(logfile) and os.path.getsize(logfile) > 0:
        rh.doRollover()

    if os.path.exists(new_repo):
        if force:
            print "Existing copy found, removing to start from fresh"
            shutil.rmtree(new_repo)
        else:
            parser.error("Target repository path (%s) already exists, cannot create" % new_repo)

    print "Cloning local repo to new path"
    remote_ref = local_clone.git.config("--get", "remote.origin.url", with_exceptions=False)
    if remote_ref:
        local_clone.git.clone("--reference", src_repo, remote_ref,
                            os.path.abspath(new_repo))
    else:
        local_clone.git.clone(src_repo, os.path.abspath(new_repo))

    # make sure the git commands are run on the correct repo
    new_clone = git.Repo(new_repo)

    # make local branches of all remote branches, and prune them all
    remote_branches = new_clone.git.for_each_ref("--format","%(refname:short)","refs/remotes/origin/")
    ignore_remote_branches = ["HEAD"]
    ignore_remote_branches.append(new_clone.git.rev_parse("--abbrev-ref","HEAD").strip())
    for origin_branch in remote_branches.split():
        if origin_branch == None:
            continue
        branch = origin_branch[7:]
        if branch not in ignore_remote_branches:
            new_clone.git.branch(branch, origin_branch)
    new_clone.git.remote("rm", "origin")

    if branches == None or branches == []:
        branches = ["--", "--all"]

    print "Pruning branches \"%s\" of everything except the following paths:" % ", ".join(branches)
    print "\n".join(includes)
    print

    debug_lvl=3
    (status, last_output, last_error) = \
            new_clone.git.filter_branch("--index-filter",
                                        FilterBranch.index_filter % ' '.join(['''-e \"^%s\"''' % p for p in includes]),
                                        "--commit-filter",
                                        FilterBranch.commit_filter % debug_lvl,
                                        "-f",
                                        *branches,
                                        callback=lambda proc: git_output_process(includes, proc))

    if status != 0:
        logger.error("filter-branch failed")
        logger.info("last output: %s\nlast error: %s" % (last_output, last_error))
        print "Critical Failure"
        sys.exit(1)

    # clean up
    print "Removing refs/original/*"
    for ref in new_clone.git.for_each_ref("--format=%(refname)", "refs/original/").split():
        logger.info("Deleteing %s" % ref)
        new_clone.git.update_ref("-d", ref)

    new_clone.git.reflog("expire", "--expire=now", "--all")
    new_clone.git.gc(aggressive=True, prune="now")

    # prune branches that point to the same ref
    if keep_branches != []:
        print "Pruning duplicate branches"
        logger.info("Keeping branches %s" % keep_branches)
        for branch in keep_branches:
            new_clone.git.checkout(branch)
            prune_list = new_clone.git.branch("--no-color", "--merged", branch).split('\n')
            logger.info("Pruning branches %s" % prune_list)
            for prune_branch in prune_list:
                prune_branch = prune_branch.strip(' *')
                if prune_branch not in keep_branches:
                    logger.info("Pruning %s" % prune_branch)
                    new_clone.git.branch("-d", prune_branch)

        # switch back to default branch
        new_clone.git.checkout("master")


if __name__ == '__main__':
    parser = OptionParser(version='%prog 1.0', usage='''Usage: %prog [options]''',
                          description='''
Splits an existing repository based on a list of files/patterns
to be kept, with all history preserved and any empty commits,
including merge commits, pruned and placed under a new repository.
'''.strip('\n'))
    parser.add_option('-i', '--include-file', dest='include_file',
                      help='File containing patterns to include, one per line. ' \
                           'Basename of file will be used as the target repository ' \
                           'name and for the log file unless -n, --new-repo is set.')
    parser.add_option('-I', '--include', dest='file_pattern',
                      help='Whitespace separated list of files to include. ' \
                           'Appended to the pattern list specified by --include-file. ' \
                           'Cannot be used when multiple --include-file set.')
    parser.add_option('-r', '--src-repo', dest='src_repo',
                      help='Source repository to split. If this is local the script ' \
                           'will use it as a reference and still attempt to retrieve ' \
                           'from the original remote repo. To prevent querying of the '
                           'remote, remove the "origin" remote from the git repo.')
    parser.add_option('-n', '--new-repo', dest='target_repo',
                      help='Sets the target repository name. Created at the given path ' \
                           '(if value is a path), at the same level if just a name and ' \
                           'source repo is local or in the current working directory')
    parser.add_option('-f', '--force', action='store_true', default=False,
                      help='Force overwriting of the target path if it exists')
    parser.add_option('-b', '--branch', dest='branches', action='append',
                      help='Name of branch to process. May be specified multiple times. ' \
                           'Default is to process all branches.')
    parser.add_option('-p', '--prune', action='store_true', default=False,
                      help='Prune new repository of any branches that reference a commit ' \
                           'that is reachable from any branch specified by "--keep-branch"')
    parser.add_option('-k', '--keep-branch', action="append", dest="keep_branches",
                      help='Name of branches to prevent from being pruned. Specify one for '
                           'each branch to be kept.')

    (options, args) = parser.parse_args(sys.argv[1:])

    # resolve any options
    include_file = options.include_file
    if not (options.include_file or options.file_pattern):
        parser.error("No include pattern specified! Cannot prune repo! Set -i or -I.")

    # determine source repository to use, and whether we need to clone a local copy to
    # allow for rapid re-runs or just copy the existing local repo to the target repo and
    # prune
    clone_options = []
    if not options.src_repo:
        parser.error("No source repository specified to use! Set -s, --src-repo")
    else:
        if options.src_repo[:7] == "file://":
            src_repo = options.src_repo[7:]
        else:
            src_repo = options.src_repo

        if os.path.exists(src_repo):
            print "Using local path clone"
            clone_options.append("--no-hardlinks")
        else:
            print "Need to create a local clone of the remote repository"
            print "Currently not supported by this script"
            sys.exit(1)

    if not (options.target_repo or options.include_file):
        parser.error("No target repository set. Set -i or -n")

    # branch pruning options
    keep_branches = []
    if options.prune:
        if options.keep_branches != []:
            keep_branches = options.keep_branches
        else:
            keep_branches = ["master"]

    local_clone = git.Repo(src_repo)
    assert local_clone.bare == False


    split_repo(src_repo, options.include_file, options.file_pattern, options.target_repo, options.branches,
               options.prune, options.keep_branches, options.force)
